/*  Compilador.jj  -  Analisador Sintático */

options
{
  JDK_VERSION = "1.5";
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compilador)
import java.io.*;

public class Compilador
{
  public static void main(String args []) throws ParseException
  {
    Compilador analisador = null;
    try
    {
      System.out.println(" Inicio Exemplo de c\u00f3digo 01");
      analisador = new Compilador(new FileInputStream("codigos_exemplo/exemplo01.my"));
      analisador.inicio();
      System.out.println(" Fim Exemplo de c\u00f3digo 01");
      System.out.println("\r\n");

 	  System.out.println(" Inicio Exemplo de c\u00f3digo 02");
      analisador.ReInit(new FileInputStream("codigos_exemplo/exemplo02.my"));
      analisador.inicio();
      System.out.println(" Fim Exemplo de c\u00f3digo 02");
      System.out.println("\r\n");
      
      System.out.println(" Inicio Exemplo de c\u00f3digo 03");
      analisador.ReInit(new FileInputStream("codigos_exemplo/exemplo03.my"));
      analisador.inicio();
      System.out.println(" Fim Exemplo de c\u00f3digo 03");
      System.out.println("\r\n");
      
      System.out.println(" Inicio Exemplo de c\u00f3digo 04");
      analisador.ReInit(new FileInputStream("codigos_exemplo/exemplo04.my"));
      analisador.inicio();
      System.out.println(" Fim Exemplo de c\u00f3digo 04");
      System.out.println("\r\n");
      
      System.out.println(" Inicio Exemplo de c\u00f3digo 05");
      analisador.ReInit(new FileInputStream("codigos_exemplo/exemplo05.my"));
      analisador.inicio();
      System.out.println(" Fim Exemplo de c\u00f3digo 05");
      System.out.println("\r\n");
    }
    catch (FileNotFoundException e)
    {
      System.out.println("Erro: arquivo nao encontrado");
    }
    catch (TokenMgrError e)
    {
      System.out.println("Erro lexico" + e.getMessage());
    }
    catch (ParseException e)
    {
      System.out.println("Erro sintatico" + e.getMessage());
    }
  }
}

PARSER_END(Compilador)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}


SKIP : {
   "/*" : comentariomult
}

<comentariomult> SKIP: {
   "*/" : DEFAULT |
   <~[]>
}

SKIP : {
   "//" : comentariosimples
}

<comentariosimples> SKIP: {
    <["\n","\r"]> : DEFAULT |
   <~[]>
}

TOKEN :
{
  	
  < PT_VIRG : ";" >
| 
  < ATRIB : ":=" >
}

TOKEN :
{
  < STRING_TYPE : "String" >
| 
  < INTEGER_TYPE : "Integer" >
}

TOKEN :
{
  < READ : "read" >
| 
  < PRINT : "print" >
| 
  < IF : "if" >
| 
  < ENTAO : "entao" >
| 
  < ELSE : "else" >
| 
  < ENDIF : "endIf" >
| 
  < WHILE : "while" >
| 
  < DO : "do" >
| 
  < ENDWHILE : "endWhile" >
}

TOKEN :
{
  < IDENT :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| 
  < STRING : "\"" (~[ "\"", "\n", "\r" ])* "\"" >
| 
  < INTEGER :
    (
      [ "0"-"9" ] ([ "0"-"9" ])*
    ) >
| 
  < #DIGIT : [ "0"-"9" ] >
| 
  < #LETTER : [ "A"-"Z", "a"-"z" ] >	
  //'#' indica que é um token privado, usado só na construção da AL
}

TOKEN :
{
  < MAIS : "+" >
| < MENOS : "-" >
| < MULT : "*" >
| < DIVID : "/" >
| < POT : "^" >
| < IGUAL : "==" >
| < MAIOR_IGUAL : ">=" >
| < MAIOR : ">" >
| < MENOR : "< " >
| < MENOR_IGUAL : "<=" >
| < DIFERENTE : "!=" >
| < SC_AND : "&&" >
| < SC_OR : "||" >
| < NEGACAO : "!" >
| < CONCAT : "#" >
| < PAR_E : "(" >
| < PAR_D : ")" >
}

void inicio() :
{}
{
  (
    linhaComando()
  )*
  < EOF >
}

void linhaComando() :
{}
{
  comando() < PT_VIRG >
}

void comando() :
{}
{
  declararVar()
| atribuirVar()
| print()
| read()
| concat()
| whileComando()
| ifComando()
}

void declararVar() :
{}
{
  //String teste; OU String teste := 'olá';
  //Integer teste; OU Integer teste := 10;
  //Integer soma := 1+2;
  type() atribuirVar()
}

void atribuirVar() :
{}
{
  // teste; OU teste := 'olá';
  // teste; OU teste := 10;
  // Integer soma := 1+2;
  < IDENT >
  (
    < ATRIB >
    (
      < STRING >
      (
        concatAtrib()
      )?
    | exp()
      (
        concatAtrib()
      )?
    )
  )?
}

void concat() :
{}
{
  < STRING > concatAtrib()
}

void concatAtrib() :
{}
{
  (
    < CONCAT >
    (
      < STRING >
    | exp()
    )
  )+
}

void whileComando() :
{}
{
  < WHILE > < PAR_E > exp() < PAR_D > < DO >
  (
    linhaComando()
  )*
  < ENDWHILE >
}

void ifComando() :
{}
{
  < IF > < PAR_E > exp() < PAR_D > < ENTAO >
  (
    linhaComando()
  )*
  ( < ELSE >(linhaComando())* )?
  < ENDIF >
}

void type() :
{}
{
  < STRING_TYPE >
| < INTEGER_TYPE >
}

void exp() :
{}
{
  expAnd()
  (
    < SC_OR > expAnd()
  )*
}

void expAnd() :
{}
{
  expRelac()
  (
    < SC_AND > expRelac()
  )*
}

void expRelac() :
{}
{
  expAdt()
  (
    < IGUAL > expAdt()
  | 
    < DIFERENTE > expAdt()
  | 
    < MAIOR_IGUAL > expAdt()
  | 
    < MENOR_IGUAL > expAdt()
  | 
    < MAIOR > expAdt()
  | 
    < MENOR > expAdt()
  )*
}

void expAdt() :
{}
{
  expMult()
  (
    < MAIS > expMult()
  | 
    < MENOS > expMult()
  )*
}

void expMult() :
{}
{
  expPotenc()
  (
    < MULT > expPotenc()
  | 
    < DIVID > expPotenc()
  )*
}

void expPotenc() :
{}
{
  exptNot()
  (
    < POT > exptNot()
  )*
}

void exptNot() :
{}
{
  (< NEGACAO >)? expParent()
}

void expParent() :
{}
{
  < PAR_E > exp() < PAR_D >
| < IDENT >
| < INTEGER >
}

void operador() :
{}
{
  < MAIS >
| < MENOS >
| < MULT >
| < DIVID >
| < POT >
}

void print() :
{}
{
  < PRINT >
  ( exp()| < STRING > )
}

void read() :
{}
{
  < READ >
  (  <STRING> ",")?
  (type())?
  < IDENT >
}
