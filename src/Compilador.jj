/*  Compilador.jj  -  Analisador Sintático */

options
{
  JDK_VERSION = "1.5";
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compilador)
import java.io.*;

public class Compilador
{
  public static void main(String args []) throws ParseException
  {
    Compilador analisador = null;
    try
    {
      analisador = new Compilador(new FileInputStream("prog_fonte.my"));
      analisador.inicio();
    }
    catch (FileNotFoundException e)
    {
      System.out.println("Erro: arquivo nao encontrado");
    }
    catch (TokenMgrError e)
    {
      System.out.println("Erro lexico" + e.getMessage());
    }
    catch (ParseException e)
    {
      System.out.println("Erro sintatico" + e.getMessage());
    }
  }
}

PARSER_END(Compilador)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

SKIP :
{
  "/*" : comentario
}

< comentario >
SKIP :
{
  "*/" : DEFAULT
}

TOKEN [ IGNORE_CASE ] :
{
  < EXIBE : "exibe" >
}

TOKEN :
{
  < COMMENT : "//" >
| 	
  < PT_VIRG : ";" >
| 
  < ATRIB : ":=" >
}

TOKEN :
{
  < STRING_TYPE : "string" >
| 
  < INTEGER_TYPE : "integer" >
}

TOKEN :
{
  < READ : "read" >
| 
  < PRINT : "print" >
| 
  < IF : "if" >
| 
  < ENTAO : "entao" >
| 
  < ELSE : "else" >
| 
  < ENDIF : "endIf" >
| 
  < WHILE : "while" >
| 
  < DO : "do" >
| 
  < ENDWHILE : "endWhile" >
}

TOKEN :
{
  < IDENT :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| 
  < STRING : "\"" (~[ "\"", "\n", "\r" ])* "\"" >
| 
  < INTEGER :
    (
      [ "0"-"9" ] ([ "0"-"9" ])*
    ) >
| 
  < #DIGIT : [ "0"-"9" ] >
| 
  < #LETTER : [ "A"-"Z", "a"-"z" ] >	
  //'#' indica que é um token privado, usado só na construção da AL
}



TOKEN :
{
  < MAIS : "+" >
| < MENOS : "-" >
| < MULT : "*" >
| < DIVID : "/" >
| < POT : "^" >
| < IGUAL : "==" >
| < MAIOR_IGUAL : ">=" >
| < MAIOR: ">">
| < MENOR: "< ">
| < MENOR_IGUAL : "<=" >
| < DIFERENTE : "!=" >
| < SC_AND : "&&" >
| < SC_OR : "||" >
| < NEGACAO : "!" >
| < CONCATENAR : "#" >
| < PAR_E : "(" >
| < PAR_D : ")" >
}

void inicio() :
{}
{
  (
    linhaComando()
  )*
  < EOF >
}

void linhaComando() :
{}
{
  comando() < PT_VIRG >
}

void comando() :
{}
{
  declararVar()
| atribuirVar()
| print()
| read ()
| concat()
| whileComando()
| ifComando()
}

void declararVar() :
{}
{
  //TODO: criar declarações multiplas
  // string teste, teste1, teste4; integer teste, teste3;


  //string teste; OU string teste := 'olá';
  //integer teste; OU integer teste := 10;
  //integer soma := 1+2;
  type() atribuirVar()
}

void atribuirVar() :
{}
{
  // teste; OU teste := 'olá';
  // teste; OU teste := 10;
  //integer soma := 1+2;
  < IDENT >(< ATRIB > (< STRING >| exp()))?
}

void concat() :
{}
{
   < STRING > (< CONCATENAR > < STRING >)+
}

//necessário fazer o condicional ex.: while(x==true)(...)endWhile
void whileComando() :
{}
{
  < WHILE >  <DO> (
    linhaComando()
  )* < ENDWHILE >
}

void ifComando(): {}
{

<IF> <ENTAO> 
	(linhaComando())*
	(<ELSE> (linhaComando())* )?
<ENDIF>
}

void type() :
{}
{
  < STRING_TYPE >
| < INTEGER_TYPE >
}

void exp() :
{}
{
  expAnd() ( <SC_OR> expAnd() )*
}

void expAnd(): {}
{
	expRelac()(<SC_AND> expRelac())*
}

void expRelac() :
{}
{
 	expAdt()
 	(
	<IGUAL>expAdt()|
	<DIFERENTE>expAdt()|
	<MAIOR_IGUAL>expAdt()|
	<MENOR_IGUAL>expAdt()|
	<MAIOR>expAdt()|
	<MENOR>expAdt()

 	)*


}

void expAdt() :
{}
{
 	expMult()
 	(
	<MAIS>expMult()|
	<MENOS>expMult()
 	)*
}

void expMult() :
{}
{
 exptNot()
 	(
	<MULT>expPotenc()|
	<DIVID>expPotenc()
 	)*
}

void expPotenc(): {}
{
	exptNot()(exptNot()<POT>)*
}

void exptNot():
{}
{
	expParent()(<NEGACAO>expParent())*
}

void expParent() :
{}
{
  "("exp()")"
|   < IDENT >
| < INTEGER >
}

void operador() :
{}
{
  < MAIS >
| < MENOS >
| < MULT >
| < DIVID >
| < POT >
}

void print(): {}
{

<PRINT> (exp() | <STRING>)

}

void read(): {}
{

<READ> (type())? <IDENT>

}
