/*  Compilador.jj  -  Analisador Sintático */

options
{
  JDK_VERSION = "1.5";
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compilador)
import java.io.*;

public class Compilador
{
  public static void main(String args []) throws ParseException
  {
    Compilador analisador = null;
    try
    {
      analisador = new Compilador(new FileInputStream("prog_fonte.my"));
      analisador.inicio();
    }
    catch (FileNotFoundException e)
    {
      System.out.println("Erro: arquivo nao encontrado");
    }
    catch (TokenMgrError e)
    {
      System.out.println("Erro lexico" + e.getMessage());
    }
    catch (ParseException e)
    {
      System.out.println("Erro sintatico" + e.getMessage());
    }
  }
}

PARSER_END(Compilador)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

SKIP :
{
  "/*" : comentario
}

< comentario >
SKIP :
{
  "*/" : DEFAULT
}

TOKEN [ IGNORE_CASE ] :
{
  < EXIBE : "exibe" >
}

TOKEN :
{
  < COMMENT : "//" >
| 	
  < PT_VIRG : ";" >
| 
  < ATRIB : ":=" >
}

TOKEN :
{
  < STRING_TYPE : "string" >
| 
  < INTEGER_TYPE : "integer" >
}

TOKEN :
{
  < READ : "read" >
| 
  < PRINT : "print" >
| 
  < IF : "if" >
| 
  < ENTAO : "entao" >
| 
  < ELSE : "else" >
| 
  < ENDIF : "endIf" >
| 
  < WHILE : "while" >
| 
  < DO : "do" >
| 
  < ENDWHILE : "endWhile" >
}

TOKEN :
{
  < IDENT :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| 
  < STRING : "\"" (~[ "\"", "\n", "\r" ])* "\"" >
| 
  < INTEGER :
    (
      [ "0"-"9" ] ([ "0"-"9" ])*
    ) >
|
  < #DIGIT : [ "0"-"9" ] >
| 
  < #LETTER : [ "A"-"Z", "a"-"z" ] >	
  //'#' indica que é um token privado, usado só na construção da AL
}



TOKEN :
{
  < MAIS : "+" >
| < MENOS : "-" >
| < MULT : "*" >
| < DIVID : "/" >
| < POT : "^" >
| < IGUAL : "==" >
| < MAIOR_IGUAL : ">=" >
| < MENOR_IGUAL : "<=" >
| < DIFERENTE : "!=" >
| < SC_AND : "&&" >
| < SC_OR : "||" >
| < NEGACAO : "!" >
| < CONCATENAR : "#" >
| < PAR_E : "(" >
| < PAR_D : ")" >
}

void inicio() :
{}
{
  (
    linhaComando()
  )*
  < EOF >
}

void linhaComando() :
{}
{
  comando() < PT_VIRG >
}

void comando() :
{}
{
  declararVar()
| atribuirVar()
| print()
| read ()
| concat()
| whileComando()
| ifComando() 
}

void declararVar() :
{}
{
  //TODO: criar declarações multiplas
  // string teste, teste1, teste4; integer teste, teste3;


  //string teste; OU string teste := 'olá';
  //integer teste; OU integer teste := 10;
  //integer soma := 1+2;
  type() atribuirVar()
}

void atribuirVar() :
{}
{
  // teste; OU teste := 'olá';
  // teste; OU teste := 10;
  //integer soma := 1+2;
  < IDENT >(< ATRIB > (< STRING >| expressao()))?
}

void concat() :
{}
{
   < STRING > (< CONCATENAR > < STRING >)+
}

void ifComando(): {}
{

<IF>< PAR_E >condicao()< PAR_D > <ENTAO>
    (linhaComando())*
    (<ELSE> (linhaComando())* )?
<ENDIF>
}


void whileComando() :
{}
{
  < WHILE > < PAR_E >condicao()< PAR_D > (linhaComando())+ < ENDWHILE >
}

void condicao() :
{}
{
  expressaoBool()(operadorBool() < PAR_E >(condicao())+< PAR_D >)*|
  < PAR_E >(condicao())+< PAR_D > (operadorBool())*
}

void type() :
{}
{
  < STRING_TYPE >
| < INTEGER_TYPE >
}

void expressao() :
{}
{
  fator() (operador() fator() )*
}

void expressaoBool() :
{}
{
  fatorBool() operadorBool() fatorBool()
}

void fatorBool() :
{}
{
    < INTEGER >
}

void operadorBool() :
{}
{
  < IGUAL >
| < MAIOR_IGUAL >
| < MENOR_IGUAL >
| < DIFERENTE >
| < SC_AND >
| < SC_OR >
| < NEGACAO >
}

void fator() :
{}
{
  < IDENT >
| < INTEGER >
}

void operador() :
{}
{
  < MAIS >
| < MENOS >
| < MULT >
| < DIVID >
| < POT >
}

void print(): {}
{

<PRINT> (expressao() | <STRING>)

}

void read(): {}
{

<READ> (type())? <IDENT>

}